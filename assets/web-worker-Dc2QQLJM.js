(function(){"use strict";function F(){return Math.round(Math.random()*255)}function D(){return`10000000-1000-4000-8000${-1e11}`.replace(/[018]/g,n=>(parseInt(n)^F()&15>>parseInt(n)/4).toString(16))}const x=[];function K(){const n=D();return x.indexOf(n)===-1&&x.push(x),n}function J(){let n;do n=D();while(x.indexOf(n)!==-1);return x.push(n),n}var Z=Object.freeze({__proto__:null,createGuid:K,createUniqueGuid:J});function Q(){}const tt=Q,H=console.warn;let b=class C{constructor(t,e,i,s){this.r=t,this.g=e,this.b=i,this.a=s}add(t,e,i,s){return new C(Math.min(255,this.r+t),this.g+e,this.b+i,this.a+s)}toRGBAString(){return`rgba(${~~this.r},${~~this.g},${~~this.b},${this.a})`}toHSLA(){const t=this.r/255,e=this.g/255,i=this.b/255,s=Math.min(t,e,i),r=Math.max(t,e,i),o=r-s;let c=0,h=0,a=0;return o==0?c=0:r==t?c=(e-i)/o%6:r==e?c=(i-t)/o+2:c=(t-e)/o+4,c=Math.round(c*60),c<0&&(c+=360),a=(r+s)/2,h=o==0?0:o/(1-Math.abs(2*a-1)),h=+(h*100).toFixed(1),a=+(a*100).toFixed(1),{h:c,s:h/100,l:a/100,a:this.a}}setInvert(){return this.r=255-this.r,this.g=255-this.g,this.b=255-this.b,this}invert(){return this.copy().setInvert()}setAlpha(t){return this.a=t,this}alpha(t){return this.copy().setAlpha(t)}setBrightness(t){return this.r=this.r*t,this.g=this.g*t,this.b=this.b*t,this}brightness(t){return this.copy().setBrightness(t)}setAlphaScale(t){return this.a=this.a*t,this}alphaScale(t){return this.copy().setAlphaScale(t)}setScale(t){return this.r*=t,this.g*=t,this.b*=t,this}scale(t){return this.copy().setScale(t)}copy(){return new C(this.r,this.g,this.b,this.a)}static Black(){return new C(0,0,0,1)}};var P=Object.freeze({__proto__:null,Color:b});function et(n){return B(n,1)}function it(n){return B(n,-1)}function st(n){return B(n,2)}function B(n,t){if(typeof t!="number")throw new Error("rotations parameter must be a number");if(!isFinite(t))throw new Error("rotations parameter must be a finite number");if(t=(4+t%4)%4,t==0)return n.concat();const e=[],i=n[0].length,s=n.length;for(let r=0;r<s;r++){const o=[];let c=null;switch(t){case 2:c=n[s-r-1];break}for(let h=0;h<i;h++)switch(t){case 1:c=n[i-h-1],o[h]=c[r];break;case 2:o[h]=c[i-h-1];break;case 3:c=n[h],o[h]=c[s-r-1];break}e[r]=o}return e}const{createUniqueGuid:nt}=Z,g=class g{constructor(t){this._x=void 0,this._y=void 0,this._rotation=0,this._index=void 0;const e=t||{ingame:!1,game:null};typeof e.guid=="string"?this._guid=e.guid:this._guid=nt(),this.game=e.game,this.ingame=e.ingame,e.brickform!=null&&(this.game!=null&&(this.color=this.game.getColors()[0].copy()),this.blocks=e.brickform.concat()),typeof e.x=="number"&&typeof e.y=="number"&&(this.x=e.x,this.y=e.y)}get guid(){return this._guid}get index(){return this._index}set index(t){this._index=t}clone(){const t=new g({guid:this._guid});return t._x=this._x,t._y=this._y,t.moving=this.moving,t.blocks=this.blocks.concat(),t.color=this.color.copy(),t._rotation=this._rotation,t.index=this.index,t}get x(){return this._x}set x(t){this._x=t,this.requestUpdate()}get y(){return this._y}set y(t){this._y=t,this.requestUpdate()}get containerWidth(){return this.blocks[0].length}get containerHeight(){return this.blocks.length}requestUpdate(){this.ingame&&this.game!=null&&(this.game.PENDINGUPDATE=!0)}resetPosition(){this.x=Math.round(this.game.width/2-this.blocks[0].length/2),this.y=Math.round(0-this.blocks.length)}getAbsoluteBlocks(t=null,e=0,i=0){return t==null&&(t=this.blocks),g.calcAbsoluteBlocks(t,this.x,this.y,e,i)}static calcAbsoluteBlocks(t,e,i,s=0,r=0){const o=[],c=e+s,h=i+r;for(const a in t)for(const u in t[a])t[a][u]==1&&o.push({x:c+parseInt(u),y:h+parseInt(a)});return o}checkCollision(t,e,i){for(const s in i)for(const r in i[s].blocks)for(const o in i[s].blocks[r])if(i[s].blocks[r][o]==1){const c=t==i[s].x+parseInt(o),h=e==i[s].y+parseInt(r),a=this!=i[s];if(c&&h&&a)return!1}return!0}getHeight(){return g.calcHeight(this.blocks)}static calcHeight(t){let e=0;for(const i in t)for(const s in t[i])t[i][s]==1&&(e=Math.max(e,parseInt(i)+1));return e}getWidth(){return g.calcWidth(this.blocks)}static calcWidth(t){let e=0,i=1/0;for(const s in t)for(const r in t[s])t[s][r]==1&&(e=Math.max(e,parseInt(r)+2),i=Math.min(i,parseInt(r)+2));return e-i+1}getBlockY(){let t=0,e=0;for(const i in this.blocks){for(const s in this.blocks[i])this.blocks[i][s]===!1&&t++;if(t==this.blocks[0].length)e++;else return e}}getBlockX(){return g.calcBlockX(this.blocks)}static calcBlockX(t){let e=0,i=0;for(let s=0;s<4;s++){e=0;for(const r in t)t[r][s]==0&&e++;if(e==t.length)i++;else return i}}rotate_okay(t,e,i=!1){return g.calcValidPosition(0,0,i,t.x,t.y,e,this.game.bricks,this.game,this.guid)}createRotatedRightBlocks(){return g.rotateRight(this.blocks)}static rotateRight(t){return et(t)}createRotatedLeftBlocks(){return g.rotateLeft(this.blocks)}static rotateLeft(t){return it(t)}createRotatedTwiceBlocks(){return g.rotateTwice(this.blocks)}static rotateTwice(t){return st(t)}createRotatedBlocks(t){return g.rotateBlocks(this.blocks,t)}static rotateBlocks(t,e){return B(t,e)}canRotate(t=!1,e=null){return this.rotate_okay(this,e||this.createRotatedRightBlocks(),t)}rotate(t=!1){if(this.game.running){const e=this.createRotatedRightBlocks();if(this.canRotate(t,e))this.requestUpdate();else{const i=g.calcBlockX(e),s=g.calcWidth(e);if(g.calcValidPosition_xOutRight(0,!1,this.x,i,s,this.game)){if(g.calcValidPosition_xOutLeft(0,!1,this.x,i))return!1;if(this.x++,this.rotate_okay(this,e))this.requestUpdate();else return this.x--,!1}else if(this.x--,this.rotate_okay(this,e))this.requestUpdate();else return this.x++,!1}this.blocks=e,this._rotation=(this._rotation+1)%4}}get rotation(){return this._rotation}set rotation(t){for(let e=this._rotation;e<=t;e++)this.rotate();this._rotation=t}posInfo(){return[["x",this.x],["y",this.y],["rotation",this._rotation]].map(t=>t.join(":")).join(",")}validatePosition(t=0,e=0,i=!1,s=void 0,r=void 0){return typeof s!="number"&&(s=this.x),typeof r!="number"&&(r=this.y),g.calcValidPosition(t,e,i,s,r,this.blocks,this.game.bricks,this.game,this.guid)}static calcValidPosition_xOutRight(t=0,e,i,s,r,o){if(i+r+s+t>o.width){if(e===!0)throw new Error("The brick would be out of bounds");return!1}return!0}static calcValidPosition_xOutLeft(t=0,e,i,s){if(i+s+t<0){if(e===!0)throw new Error("The brick would be out of bounds");return!1}return!0}static calcValidPosition(t=0,e=0,i,s,r,o,c,h,a){const u=g.calcBlockX(o);if(!g.calcValidPosition_xOutLeft(t,i,s,u))return!1;const l=g.calcWidth(o);if(!g.calcValidPosition_xOutRight(t,i,s,u,l,h))return!1;if(r+g.calcHeight(o)+e>h.height){if(i===!0)throw new Error("The brick would be out of bounds");return!1}if(g.calcWillCollide(t,e,c,o,s,r,a)){if(i===!0)throw new Error("The brick would collide with another brick");return!1}return!0}canMoveLeft(t=!1){if(this.game.running!=!0){if(t===!0)throw new Error("The game is not running");return!1}if(this.moving!=!0){if(t===!0)throw new Error("The brick is not flagged as moving");return!1}return this.validatePosition(-1,0,t)}moveleft(t=!1){if(this.game.running){if(this.ingame===!0&&this.game.runEvent("fx",null,"sound","gamemove"),this.canMoveLeft(t))return this.x--,!0;if(t===!0)throw new Error("Unknown reason");return!1}else if(t===!0)throw new Error("The game is not running");return!1}get innerX(){return this.x-this.getBlockX()}get innerXfar(){return this.innerX+this.innerWidth}get mostLeft(){return g.calcMostLeft(this.blocks)}static calcMostLeft(t){return~~-g.calcBlockX(t)}get mostRight(){return g.calcMostRight(this.game.width,this.blocks)}static calcMostRight(t,e){return~~(t-g.calcWidth(e)-g.calcBlockX(e))}get innerWidth(){return this.getWidth()}willCollide(t,e,i=null,s=null){return s==null&&(s=this.blocks),i==null&&(i=this.game.bricks),g.calcWillCollide(t,e,i,s,this.x,this.y,this.guid)}static calcWillCollide(t,e,i,s,r,o,c){const h=g.calcAbsoluteBlocks(s,r,o,t,e);for(const a of i){if(a.guid===c)continue;const u=a.getAbsoluteBlocks();for(const l of h)for(const f of u)if(f.x===l.x&&f.y===l.y)return!0}return!1}canMoveRight(t=!1){if(this.game.running!=!0){if(t===!0)throw new Error("The game is not running");return!1}if(this.moving!=!0){if(t===!0)throw new Error("The brick is not flagged as moving");return!1}return this.validatePosition(1,0,t)}moveright(t=!1){if(this.game.running){if(this.ingame===!0&&this.game.runEvent("fx",null,"sound","gamemove"),this.canMoveRight(t))return this.x++,!0;if(t===!0)throw new Error("Unknown reason");return!1}else if(t===!0)throw new Error("The game is not running");return!1}canSmashDown(t=!1){if(this.game.running!=!0){if(t===!0)throw new Error("The game is not running");return!1}return!0}smashdown(t=!1){if(this.canSmashDown(t))if(this.ingame===!0&&this.game.runEvent("fx",null,"sound","gamebump"),this.moving=!1,this.y=this.getLowestPosition(),this.requestUpdate(),this.y+this.getBlockY()>=0){const e=this.slice_up();this.game.bricks.splice(this.findMe(),1);for(const i in e)this.game.bricks.push(e[i]);this.game.checkLines(),this.game.addNewBrick(),this.game.HOLDINGCOUNT=0}else this.game.loseView(),this.ingame===!0&&this.game.runEvent("fx",null,"sound","gamelose")}canMoveDown(t=!1){if(this.game.running!=!0){if(t===!0)throw new Error("The game is not running");return!1}if(this.moving!=!0){if(t===!0)throw new Error("The brick is not flagged as moving");return!1}return this.validatePosition(0,1,t)}movedown(t=!1){if(this.game.running&&this.moving)if(this.canMoveDown(t))this.y++;else if(this.moving=!1,this.ingame===!0&&this.game.runEvent("fx",null,"sound","gamebump"),this.y+this.getBlockY()>=0){const e=this.slice_up();this.game.bricks.splice(this.findMe(),1);for(const i in e)this.game.bricks.push(e[i]);this.game.checkLines(),this.game.addNewBrick(),this.game.HOLDINGCOUNT=0}else this.game.loseView(),this.ingame===!0&&this.game.runEvent("fx",null,"sound","gamelose")}getLowestPosition(t=0){return g.calcLowestPosition(this.blocks,t,this.game.height,this.game.bricks,this.x,this.y,this.guid)}static calcLowestPosition(t,e=0,i,s,r,o,c){const h=g.calcHeight(t);let a=0;for(;!(o+a+h>i||g.calcWillCollide(e,a,s,t,r,o,c));)a++;return o+a-1}slice_up(){const t=[],e=this.color;for(const i in this.blocks)for(const s in this.blocks[i])this.blocks[i][s]==!0&&t.push(((r,o,c)=>{const h=new g;return h.moving=!1,h.blocks=[[!0]],h.color=e,h.x=r,h.y=o,h.id=c.id,h.index=c.index,h})(parseInt(s)+this.x,parseInt(i)+this.y,this));return t}findMe(){for(const t in this.game.bricks)if(this.game.bricks[t]==this)return parseInt(t);return H("findMe could not find brick in game"),-1}};g.emulate=t=>{const e=new g({ingame:!1,game:null});return e.moving=!1,e.blocks=t,e};let d=g;class rt{constructor(){}initialize(){throw new Error("Missing implementation")}initializeInput(){}initRender(){throw new Error("Missing implementation")}clear(){throw new Error("Missing implementation")}setGame(t){this._game=t}get game(){return this._game}}class A{constructor(t){this._gradient=t}addColor(t,e){this._gradient.addColorStop(t,e.toRGBAString())}compile(){return this._gradient}}class ot extends A{constructor(t,...e){const i=e.map((u,l)=>({x:u,i:l})).filter(u=>typeof u.x!="number");if(i.length>0)throw new Error("Args at "+i.map(u=>u.i).join(", ")+" is not numbers");const[s,r,o,c,h,a]=e;super(t.createRadialGradient(s,r,o,c,h,a))}}class N extends A{constructor(t,...e){const i=e.map((h,a)=>({x:h,i:a})).filter(h=>typeof h.x!="number");if(i.length>0)throw new Error("Args at "+i.map(h=>h.i).join(", ")+" is not numbers");const[s,r,o,c]=e;super(t.createLinearGradient(s,r,o,c))}}const U=[];class ct{constructor(t,e,i,s,r){this._color=t,this._width=e,this._height=i,this._countX=s,this._countY=r}get key(){return"C:"+this._color.toRGBAString()+"W:"+this._width+"H:"+this._height+"X:"+this._countX+"Y:"+this._countY}matches(t){return this.key===t.key}}function ht(n,t,e,i,s){const r=new ct(n,t,e,i,s),o=U.filter(h=>r.matches(h.key));if(o.length>0)return o[0].data;const c={key:r,data:at(n,t,e,i,s)};return U.push(c),c.data}function at(n,t,e,i,s){const r=new OffscreenCanvas(t*i,e*s),o=r.getContext("2d");o.strokeStyle=n.toRGBAString(),o.lineWidth=2;for(let c=0;c<=i;c++)o.beginPath(),o.moveTo(c*t,0),o.lineTo(c*t,r.height),o.closePath(),o.stroke();for(let c=0;c<=s;c++)o.beginPath(),o.moveTo(0,c*e),o.lineTo(r.width,c*e),o.closePath(),o.stroke();return o.getImageData(0,0,r.width,r.height)}function S(n,t,e,i,s,r){const o=ht(t,e,i,s,r);n.putImageData(o,0,0)}class lt extends rt{constructor({gameOffscreenCanvas:t,holdingOffscreenCanvas:e,nextOffscreenCanvas:i}){super(),this._brickSize=30,this._state=null,this._gameCtx=t.getContext("2d"),this._holdingCtx=e.getContext("2d"),this._nextCtx=i.getContext("2d")}get score(){return this._score}get brickSize(){return this._brickSize}set brickSize(t){this._brickSize=t}get gameCtx(){return this._gameCtx}initializeInput(){postMessage({type:"init-input"})}clearCanvases(){this.clearCanvas(this._gameCtx,this.canvasWidth,this.canvasHeight),this.clearCanvas(this._holdingCtx,this.brickSize*4,this.brickSize*4),this.clearCanvas(this._nextCtx,this.brickSize*4,this.brickSize*4)}clear(){this.clearState()}drawGrid(){S(this._gameCtx,this.game.gridColor,this.brickSize,this.brickSize,this.game.width,this.game.height);const e=this.brickSize/1.5;S(this._nextCtx,this.game.gridColor,e,e,6,6),S(this._holdingCtx,this.game.gridColor,e,e,6,6)}clearState(){this._state==null&&(this._state={bricks:{holding:[],game:[],next:[]}}),this.clearArray(this._state.bricks.holding);const t=this.clearArray(this._state.bricks.game);return this.clearArray(this._state.bricks.next),t}clearArray(t){return t.splice(0,t.length)}addToState({brick:t,old:e,state:i,x:s,y:r,blocks:o,color:c,scale:h=1}){typeof e>"u"&&(e=i);let a=t!=null?e.filter(u=>u.brick===t)[0]:null;if(typeof s!="number")if(t instanceof d)s=t.x;else throw new Error("Missing x coordinate");if(typeof r!="number")if(t instanceof d)r=t.y;else throw new Error("Missing x coordinate");if(typeof o>"u")if(t instanceof d)o=t.blocks;else throw new Error("Missing blocks");if(typeof c>"u")if(t instanceof d)c=t.color;else throw new Error("Missing color");a==null?a={brick:t,fromX:s,fromY:r,toX:s,toY:r,blocks:o,color:c,scale:h,fromStamp:new Date().getTime()}:(a.fromX=a.currentX,a.fromY=a.currentY,a.toX=s,a.toY=r,a.blocks=o,a.color=c,a.scale=h,a.fromStamp=new Date().getTime()),i.indexOf(a)===-1&&i.push(a)}drawBricks(){const t=this.clearState(),e=1.5,i=this.game.bricks;for(const s in i){if(this.game.ghostDrawing&&i[s].moving){const r=new b(255,255,255,.2),o=i[s].getLowestPosition();this.addToState({state:this._state.bricks.game,blocks:i[s].blocks,x:i[s].x,y:o,color:r})}this.addToState({state:this._state.bricks.game,old:t,brick:i[s]})}this.addToState({state:this._state.bricks.next,blocks:this.game.brickforms[this.game.nextRandom],x:2,y:2,color:this.game.colors[this.game.nextRandom],scale:e}),this.game.holding!=null&&this.addToState({state:this._state.bricks.holding,brick:this.game.holding,x:2,y:2,scale:e})}drawStates(){this.drawState(this._state.bricks.holding,this._holdingCtx),this.drawState(this._state.bricks.game,this._gameCtx),this.drawState(this._state.bricks.next,this._nextCtx)}mix(t,e,i){return t*(1-i)+e*i}updateBrickState(t){t.currentX=t.toX,t.currentY=t.toY}drawState(t,e){for(const i of t)this.updateBrickState(i),this.drawBrickForm(i.blocks,e,i.currentX,i.currentY,i.color,i.scale)}drawBrickForm(t,e,i,s,r,o=1){for(const c in t)for(const h in t[c])t[c][h]===!0&&this.drawSquare(e,i+parseInt(h),s+parseInt(c),r,o)}drawSquare(t,e,i,s,r=1){const o=this.brickSize/r,c=e*o,h=i*o,a=o,u=o;let l=new ot(t,c+a/2,h+u/2,0,c+a/2,h+u/2,40);l.addColor(0,s),l.addColor(1,s.alphaScale(.5)),t.fillStyle=l.compile(),t.fillRect(c,h,a,u),l=new N(t,c+a/2,h,c+a/2,h+u),l.addColor(.2,s.alpha(.5)),l.addColor(0,b.Black().alpha(.9)),t.fillStyle=l.compile(),t.fillRect(c,h,a,u),l=new N(t,c,h+u/2,c+a,h+u/2),l.addColor(.3,s.scale(.7).alpha(0)),l.addColor(0,b.Black().alpha(.4)),t.fillStyle=l.compile(),t.fillRect(c,h,a,u),l=new N(t,c+a/2,h,c+a/2,h+u),l.addColor(.8,s.scale(.1).alpha(0)),l.addColor(1,b.Black()),t.fillStyle=l.compile(),t.fillRect(c,h,a,u),l=new N(t,c,h+u/2,c+a,h+u/2),l.addColor(.8,s.scale(.2).alpha(0)),l.addColor(1,b.Black()),t.fillStyle=l.compile(),t.fillRect(c,h,a,u)}clearCanvas(t,e,i){t.clearRect(0,0,t.canvas.width,t.canvas.height),t.canvas.width=e,t.canvas.height=i}get canvasWidth(){return this.brickSize*this.game.width}get canvasHeight(){return this.brickSize*this.game.height}initRender(){this.render(!0,!0),this.game.addEvent("update-score",t=>{postMessage({type:"update-score",score:t})})}render(t=!1,e=!1){const i=this.game;(t===!0||i.PENDINGUPDATE)&&(this.drawBricks(),i.PENDINGUPDATE=!1),this.clearCanvases(),this.drawGrid(),this.drawStates(),e===!0&&requestAnimationFrame(()=>this.render(!1,e))}}function z(n){const t=n.getMovingBrick();t?.movedown(),n.runEvent("tick",null)}function ut(n){const t=()=>{n.setup.clickTick!==!0&&z(n),setTimeout(t,n.movingSpeed)};t()}class q{constructor(t){this._handlers=[],this._defaultThis=null,this._defaultThis=t}on(t,e){this._handlers.push({name:t,handler:e})}trigger(t,e,...i){e===null&&(e=this._defaultThis);for(const s of this._handlers)s.name===t&&s.handler.apply(e,i)}}class gt{constructor({x:t,y:e,brickMatrix:i}){this.x=t,this.y=e,this.brickMatrix=i,this.score=null}}class ft extends gt{constructor(t){super(t);const{rotation:e,needsHolding:i}=t;this.rotation=e,this.needsHolding=i,this.holdingFired=!1}getNextInstruction(){return e=>{if(this.needsHolding===!0&&this.holdingFired!==!0){this.holdingFired=!0,e.holdingShift();return}const i=e.getMovingBrick();if(i.rotation===this.rotation&&i.x===this.x){e.input.smashDown();return}e.moveTowards(this.x,this.rotation)}}}function X(n,t,e,i){const s=[],r=i;for(let o=0;o<4;o++){const c=d.rotateBlocks(r.blocks,o),h=d.calcMostLeft(c),a=d.calcMostRight(n,c);for(let u=h;u<=a;u++){const l=d.calcLowestPosition(c,u-r.x,t,e,r.x,r.y,r.guid),f=p.renderBrickMatrix(n,t,e,[{guid:r.guid,x:u,y:l,blocks:c}]);s.push(new ft({brickMatrix:f,x:u,y:l,rotation:o}))}}return s}function k(n,t=!1){const e=function(i,s){return(r,o)=>i(s?o:r)-i(s?r:o)};return{sorters:[e(n,t)],thenBy:function(i,s=!1){return this.sorters.push(e(i,s)),this},compare:function(i,s){for(const r of this.sorters){const o=r(i,s);if(o!==0)return o}return 0},execute(i){return i.concat().sort((s,r)=>this.compare(s,r))}}}function dt(n){let t=0;for(let e=n.length-1;e>=0;e--)n[e].filter(i=>i!==!0).length===0&&t++;return t}function Y(n){const t=n.length,e=n[0].length,i=[];for(;i.length<e;){const s=[];for(;s.length<t;)s.push(void 0);i.push(s)}for(let s=0;s<t;s++)for(let r=0;r<e;r++)i[r][s]=n[s][r];return i}function mt(n){let t=0;n=Y(n);for(let e=0;e<n.length;e++){const i=n[e].indexOf(!0);if(i!==-1)for(let s=i;s<n[e].length;s++)n[e][s]===!1&&t++}return t}function kt(n){let t=0;n=Y(n);let e=null;for(let i=0;i<n.length;i++){const s=n[i];e==null&&(e=s.length);const r=s.indexOf(!0);if(r<0)continue;const o=s.length-r;o>t&&(t=o)}return{blocksHeight:t,gameHeight:e}}class T{constructor({clearingLines:t,holes:e,height:i}){this.clearingLines=t,this.holes=e,this.height=i}getRatio(t,e){const i=j(t.clearingLines,e.clearingLines,this.clearingLines),s=j(t.holes,e.holes,this.holes),r=1-this.height.blocksHeight/this.height.gameHeight;return(i*2+s*3+r)/6}}function wt(n){const t=dt(n),e=mt(n),i=kt(n);return new T({holes:e,height:i,clearingLines:t})}function j(n,t,e){return n==t?1:(e-n)/(t-n)}function _t(n){n=n.concat();const t=k(s=>s.scores.clearingLines,!1).execute(n)[0].scores.clearingLines,e=k(s=>s.scores.height.blocksHeight/s.scores.height.gameHeight,!0).execute(n)[0].scores.height,i=k(s=>s.scores.holes,!0).execute(n)[0].scores.holes;return new T({clearingLines:t,holes:i,height:e})}function bt(n){n=n.concat();const t=k(s=>s.scores.clearingLines,!0).execute(n)[0].scores.clearingLines,e=k(s=>s.scores.height.blocksHeight/s.scores.height.gameHeight,!1).execute(n)[0].scores.height,i=k(s=>s.scores.holes,!1).execute(n)[0].scores.holes;return new T({clearingLines:t,holes:i,height:e})}function V(n){const t=_t(n),e=bt(n);return k(i=>i.scores.getRatio(t,e),!0).thenBy(i=>i.scores.clearingLines,!0).thenBy(i=>i.scores.holes,!1).thenBy(i=>i.scores.height,!1).execute(n)}const{Color:pt}=P;function M(n,t){const i={bricks:n.bricks.concat().map(o=>o.clone())};n.HOLDING!=null&&(i.holding=n.HOLDING.clone());const s=Object.assign({},n.setup,t,{brickforms:n.setup.brickforms,width:n.setup.width,height:n.setup.height,sequence:n.setup.sequence}),r=new p(s,i);return r.brickforms=n.brickforms,r.HOLDINGCOUNT=n.HOLDINGCOUNT,r}function L(n,t){let e=[];for(const i of X(n.width,n.height,n.bricks,n.getMovingBrick()))e.push(i);if(n.canUseHolding){const i=M(n,t);i.holdingShift();for(const s of X(i.width,i.height,i.bricks,i.getMovingBrick()))s.needsHolding=!0,e.push(s)}for(const i of e)i.scores=wt(i.brickMatrix);return e=V(e),e}class vt{constructor(){this._movements=[],this._cancelled=!1,this._mode="assist",this._simulation=[],this._starttime=0,this._eventController=new q(this)}attach(t){this._game=t,this._game.addEvent("current-brick-change",()=>{this.getNewMove()})}drawMovements(){if(this._movements.length>0){const t=this._movements[0].brick,e=new pt(255,255,255,.2);setTimeout(()=>this._game.drawBrick(t,e),50)}}cancel(){this._cancelled=!0}get isCancelled(){return this._cancelled}start(){if(this._starttime=new Date().getTime(),this._game.setup.clickTick===!0)this._game.ghostDrawing=!1,this._game.addEvent("tick",()=>{this.isCancelled===!1&&(this.tick(),this.drawMovements())});else{const t=()=>{this.isCancelled===!1&&(this.tick(),setTimeout(t,this.getTimeout()))};setTimeout(t,0)}this._game.addEvent("lose",()=>{this.cancel()})}getTimeout(){return 100}setMode(t){this._mode=t}setSimulation(t){this._simulation=JSON.parse(JSON.stringify(t))}tick(){if(this._game.running===!0)if(this._mode==="assist")this.assistTick();else if(this._mode==="playback")this.playbackTick();else throw new Error("Mode is not supported: "+this._mode)}getNewMove(){this._movements=L(this._game,{nextBrick:new G(0)}),this._eventController.trigger("update-movements",null,this._movements.concat())}addEvent(t,e){this._eventController.on(t,e)}get targetMovement(){if(!(this._movements.length<1))return this._movements[0]}assistTick(){const t=this.targetMovement;if(t==null)return;const e=t.getNextInstruction();if(!(typeof e>"u"))if(typeof e=="function")e(this._game)instanceof Promise&&H("TODO: async handle / promise await missing");else throw new Error("Unknown instruction type")}playbackTick(){throw new Error("Not implemented")}get movements(){return this._movements}}function xt(n,t=!0){const e=new vt;return e.attach(n),Array.isArray(n.setup.simulation)&&(e.setMode("playback"),e.setSimulation(n.setup.simulation)),t===!0&&e.start(),e}var yt=Object.freeze({__proto__:null,attachSimulator:xt,cloneGame:M,getPossibleMoves:L});let E=class{constructor(){}nextBrick(t){const e=t.nextRandom;let i=e;for(;i===e;)i=Math.round(Math.random()*(t.brickforms.length-1));return i}};class G extends E{constructor(t){super(),this._v=t}nextBrick(){return this._v}}class W extends E{constructor(t=null){super(),this._fallback=t||new E}nextBrick(t){const e=t.bricks.concat().sort((r,o)=>o.id-r.id)[0],i=[];for(let r=0;r<t.brickforms.length;r++){if(e!=null&&r==e.index)continue;const o=this.getPossibleMovesForType(t,r)[0];i.push({i:r,move:o})}return V(i)[0].move.brick.index}getPossibleMovesForType(t,e){const i={nextBrick:new G(e)},s=M(t,i);return s.addNewBrick(),L(s)}}var Bt=Object.freeze({__proto__:null,EasyNextBrick:W,NextBrick:E,StaticNextBrick:G});function Nt(){throw new Error("Not implemented")}function Et(){throw new Error("Not implemented")}var It=Object.freeze({__proto__:null,receiver:Et,transmitter:Nt});const R={AFTER_INIT:"after-init"};class Ct{constructor(){this._addons=[],this._typesLoaded=[]}add(t,e,i){let s;switch(i){case R.AFTER_INIT:s={initType:i,object:t,callback:e,loaded:!1};break;default:throw new Error("Unknown INIT_TYPE: "+i)}this._addons.push(s),this.typeIsAlreadyLoaded(i)&&this.loadAddon(s)}typeIsAlreadyLoaded(t){return this._typesLoaded.indexOf(t)!==-1}loadByType(t){if(this.typeIsAlreadyLoaded(t))throw new Error("Type "+t+" has already been loaded");this._typesLoaded.push(t);for(const e of this._addons)e.initType===t&&e.loaded===!1&&this.loadAddon(e)}loadAddon(t){if(t.loaded!==!1)throw new Error("Addon is already loaded");t.loaded=!0,t.callback(t.object)}}class St{constructor(t){this._game=t}smashDown(){this._game.running===!0&&this._game.getMovingBrick().smashdown(!0)}left(){this._game.running===!0&&this._game.getMovingBrick().moveleft()}rotate(){this._game.running===!0&&this._game.getMovingBrick().rotate()}right(){this._game.running===!0&&this._game.getMovingBrick().moveright()}down(){this._game.running===!0&&this._game.getMovingBrick().movedown()}hold(){this._game.running===!0&&this._game.holdingShift()}}const{attachSimulator:Tt}=yt,{Color:m}=P,{transmitter:Mt}=It,{NextBrick:Lt}=Bt;class p{constructor(t,e=null,i=null){if(this._SETTING_GHOST=!0,this._HOLDING=null,this._PENDINGUPDATE=!1,this._HOLDINGCOUNT=0,this._currentSequence=-1,this._bricks=[],this._eventController=new q(this),this._addons=new Ct,this._simulator=null,this._RUNNING=!0,this._socket=null,this.socket=null,this._logEntries=[],this._score=0,this._setup=t,this._nextRandomGenerator=t.nextBrick||new Lt,this._graphicEngine=i,this._graphicEngine!=null&&this._graphicEngine.setGame(this),t.logger===!0&&this.addLogEntry({name:"gameInit"}),this._width=t.width,this._height=t.height,this._gameGuid=Math.round(Math.random()*1e16),this._gridColor=new m(0,255,0,.5),e!=null){if(Array.isArray(e.bricks)){this._bricks=e.bricks.concat();for(const c of this._bricks)c.game=this}e.holding!=null&&(this._HOLDING=e.holding,this._HOLDING.game=this)}this.brickforms=t.brickforms;const s=[new m(255,0,0,1),new m(0,255,0,1),new m(0,0,255,1),new m(255,255,0,1),new m(0,255,255,1),new m(255,0,255,1),new m(0,128,128,1)];this.setNextRandom();const r=this;this.getColors=()=>s;function o(c){if(this._RUNNING){this.score++,this.runEvent("fx",null,"sound","gamerow");const h=r.bricks;(a=>{const u=[];let l=0;for(l=0;l<=this.width;l++)for(const f in h)for(const w in h[f].blocks)for(const _ in h[f].blocks[w])if(h[f].blocks[w][_]===!0){const O=a==h[f].y+parseInt(w),At=h[f].moving==!1;O&&At&&h.splice(parseInt(f),1)}return u})(c),(a=>{const u=[];for(const l in h)for(const f in h[l].blocks)for(const w in h[l].blocks[f])if(h[l].blocks[f][w]===!0){const _=a>h[l].y+parseInt(f),O=h[l].moving==!1;_&&O&&h[l].y++}return u})(c)}}this.checkLines=()=>{if(this._RUNNING){let c;for(let h=this.height;h>1;h--){let a=0;for(c=0;c<=this.width-1;c++)this.checkXY(c,h)&&a++;a==this.width&&o.call(this,h++)}this.PENDINGUPDATE=!0}},this.init=function(){if(this._RUNNING=!0,this.score=0,this.HOLDINGCOUNT=0,this.setup.simulator===!0&&(this._simulator=Tt(this)),this.addNewBrick(),ut(this),this.setup.logger===!0){const c=Mt();setInterval(()=>{if(this._socket!=null&&this._socket.readyState===this._socket.OPEN){let h;for(;(h=this._logEntries.splice(0,1)).length>0;)for(const a of h)this._socket.send(JSON.stringify(a))}}),this._socket=c}this._graphicEngine!=null&&(this._graphicEngine.initializeInput(),this._graphicEngine.initRender()),this._addons.loadByType(R.AFTER_INIT)},this.input=new St(this)}get gridColor(){return this._gridColor}registerAddon(t,e,i){this._addons.add(t,s=>e(s,this),i)}get simulator(){return this._simulator}get graphicsEngine(){return this._graphicEngine}get score(){return this._score}set score(t){this._score=t,this._eventController.trigger("update-score",null,t)}get colors(){return this.getColors()}get holding(){return this._HOLDING}set holding(t){this._HOLDING=t}renderBrickMatrix(t=[]){return p.renderBrickMatrix(this.width,this.height,this.bricks,t)}static renderBrickMatrix(t,e,i,s=[]){s=s.concat();const r=[];for(let o=0;o<e;o++){r.push([]);for(let c=0;c<t;c++)r[r.length-1].push(!1)}for(const o of i){let c=o.blocks,h=o.x,a=o.y;const u=s.filter(l=>l.guid==o.guid);if(u.length>1)throw new Error("There were multiple modifications found for a single brick!");if(u.length==1){const l=u[0];typeof l.x=="number"&&(h=l.x),typeof l.y=="number"&&(a=l.y),typeof l.blocks<"u"&&(c=l.blocks),s.splice(s.indexOf(l),1)}for(const l in c)for(const f in c[l])if(c[l][f]===!0){const w=h+parseInt(f),_=a+parseInt(l);if(_<0||_>e)continue;r[_][w]=!0}}if(s.length>0)throw new Error(`There were ${s.length} modifications which is not used`);return r}get movingSpeed(){return 1e3}get canUseHolding(){return this.HOLDINGCOUNT<1}getBrickId(){return(this.bricks.length>0?this.bricks.map(e=>e.id).sort((e,i)=>i-e)[0]:0)+1}addNewBrick(t=-1){const e=new d({game:this,ingame:!0});e.id=this.getBrickId();const i=this.brickforms,s=this.nextRandom;e.color=this.getColors()[s].copy(),e.blocks=i[s].concat(),e.index=s,e.moving=!0,e.resetPosition(),this.logEvent({name:"newBrick",blocks:e.blocks}),this.setNextRandom(),t===-1?this.bricks.push(e):this.bricks[t]=e,this._eventController.trigger("current-brick-change",null)}logEvent(t){if(this.setup.logger===!0){const e=this._gameGuid,s={action:"log",time:new Date().getTime(),data:Object.assign({gameGuid:e},t)};this.addLogEntry(s)}}addLogEntry(t){this._logEntries.push(t)}holdingShift(){if(this.canUseHolding)if(this._HOLDING==null)this._HOLDING=this.getMovingBrick(),this.addNewBrick(this.getMovingBrick().findMe()),this.HOLDINGCOUNT++;else{const t=this._HOLDING;this._HOLDING=this.getMovingBrick(),t.resetPosition(),this.bricks[this.getMovingBrick().findMe()]=t,this.HOLDINGCOUNT++}}getMovingBrick(){for(const t in this.bricks)if(this.bricks[t].moving)return this.bricks[t]}clone(){return new p}action_smashdown(){this.input.smashDown()}action_moveleft(){this.input.left()}action_rotate(){this.input.rotate()}action_moveright(){this.input.right()}action_movedown(){this.input.down()}get ghostDrawing(){return this._SETTING_GHOST}set ghostDrawing(t){this._SETTING_GHOST=t}get brickforms(){return this._brickforms}set brickforms(t){this._brickforms=t}get HOLDING(){return this._HOLDING}get HOLDINGCOUNT(){return this._HOLDINGCOUNT}set HOLDINGCOUNT(t){this._HOLDINGCOUNT=t}get PENDINGUPDATE(){return this._PENDINGUPDATE}set PENDINGUPDATE(t){this._PENDINGUPDATE=t}get nextRandom(){return this._nextRandom}set nextRandom(t){this._nextRandom=t}setNextRandom(){Array.isArray(this.setup.sequence)?(this._currentSequence=(this._currentSequence+1)%this.setup.sequence.length,this.nextRandom=this.setup.sequence[this._currentSequence]):this.nextRandom=this._nextRandomGenerator.nextBrick(this)}get running(){return this._RUNNING}get width(){return this._width}get height(){return this._height}get bricks(){return this._bricks}set bricks(t){t==""&&typeof[]=="object"&&(this.score=0,this.HOLDINGCOUNT=0,this._HOLDING=null,this._bricks=[])}checkXY(t,e){const i=this.bricks;for(const s of i)for(let r=0,o=s.blocks.length;r<o;r++)for(let c=0,h=s.blocks[r].length;c<h;c++)if(s.blocks[r][c]===!0){const a=t==s.x+~~c,u=e==s.y+~~r,l=s.moving==!1;if(a&&u&&l)return!0}return!1}get setup(){return this._setup}moveTowards(t,e=null){const i=this.getMovingBrick();if(typeof e=="number"&&e!=this.getMovingBrick().rotation){tt("rotating from "+this.getMovingBrick().rotation+" to "+e),this.action_rotate();return}i.x>t?this.action_moveleft():i.x<t?this.action_moveright():this.action_smashdown()}addEvent(t,e){this._eventController.on(t,e)}runEvent(t,e,...i){this._eventController.trigger.apply(this._eventController,[t,e].concat(i))}loseView(){this.runEvent("fx",null,"sound","gamelose"),this._RUNNING=!1,this._eventController.trigger("lose",null),this.setup.simulator===!0&&setTimeout(()=>this.runEvent("restart",null),2e3)}}function v(n){return typeof n=="number"?n>=1:n.map(t=>v(t))}class y{constructor(t,e,i,s={}){this._sequence=null,this._nextBrick=null,this.logger=!1,this._brickforms=t,this._width=e,this._height=i,this._graphics=s.graphics,this._nextBrick=s.nextBrick}get nextBrick(){return this._nextBrick}get brickforms(){return this._brickforms}get width(){return this._width}get height(){return this._height}get sequence(){return this._sequence}get graphics(){return this._graphics}setSequence(){this._sequence=this.brickforms.concat().map((t,e)=>e)}}function Gt(){const n=[[[0,1,0],[0,1,0],[0,1,1]],[[0,1,0],[0,1,0],[1,1,0]],[[0,1,1],[1,1,0],[0,0,0]],[[1,1,0],[0,1,1],[0,0,0]],[[0,1,0],[1,1,1],[0,0,0]],[[1,1],[1,1]],[[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0]]];return new y(v(n),10,20)}function Rt(){const n=[[[0,1,0],[0,1,0],[0,1,1]],[[0,1,0],[0,1,0],[1,1,0]],[[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0]]],t=new y(v(n),10,20);return t.setSequence(),t}function Ot(){const n=[[[1,1],[1,1]]];return new y(v(n),10,20)}function Dt(){const n=[[[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0]]];return new y(v(n),10,20)}function Ht(){const n=[[[0,1,1],[1,1,0],[0,0,0]]];return new y(v(n),10,20)}function Pt(n,t){let e;switch(n.setup){case"ez":e=Ot();break;case"ez2":e=Rt();break;case"long":e=Dt();break;case"shit":e=Ht();break;default:e=Gt();break}switch(n.next){case"ez":e.nextBrick=new W;break}switch(n.simulate){case!0:e.simulator=!0;break;case"assistbug":{e.simulator=!0,e.simulation=[];let s=0;for(let r=0;r<5;r++){for(let o=0;o<4;o++)e.simulation.push({type:"nextRandom",val:0,time:s+=100}),e.simulation.push({type:"nextRandom",val:0,time:s+=100});e.simulation.push({type:"nextRandom",val:0,time:s+=100})}}break}n.clickTick===!0&&(e.clickTick=!0),n.logger==="1"&&(e.logger=!0),n.view==="lite"&&window.document.body.classList.add("lite-view");const i=new p(e,null,t);return i.init(),i}let $,I;addEventListener("message",n=>{const{type:t}=n.data;if(t==="init"){const{options:e,gameOffscreenCanvas:i,holdingOffscreenCanvas:s,nextOffscreenCanvas:r}=n.data;$=new lt({gameOffscreenCanvas:i,holdingOffscreenCanvas:s,nextOffscreenCanvas:r}),I=Pt(e,$),I.addEvent("restart",()=>{postMessage({type:"restart"})}),e.sound!=="off"&&(postMessage({type:"init-fx"}),I.registerAddon({},(o,c)=>{c.addEvent("fx",(h,a)=>{h==="sound"&&postMessage({type:"fx",name:a})})},R.AFTER_INIT)),postMessage({type:"inited"})}else if(t==="input"){const e=I;if(!e)return;switch(n.data.action){case"left":e.input.left();break;case"right":e.input.right();break;case"down":e.input.down();break;case"rotate":e.input.rotate();break;case"smash":e.input.smashDown();break;case"holdingShift":e.holdingShift();break;case"hold":e.input.hold();break;case"sendTick":e.setup.clickTick===!0&&z(e);break}}})})();
