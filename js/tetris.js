var tetris =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\nmodule.exports = function (useSourceMap) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item, useSourceMap);\n\n      if (item[2]) {\n        return \"@media \".concat(item[2], \"{\").concat(content, \"}\");\n      }\n\n      return content;\n    }).join('');\n  }; // import a list of modules into the list\n  // eslint-disable-next-line func-names\n\n\n  list.i = function (modules, mediaQuery) {\n    if (typeof modules === 'string') {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, '']];\n    }\n\n    var alreadyImportedModules = {};\n\n    for (var i = 0; i < this.length; i++) {\n      // eslint-disable-next-line prefer-destructuring\n      var id = this[i][0];\n\n      if (id != null) {\n        alreadyImportedModules[id] = true;\n      }\n    }\n\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = modules[_i]; // skip already imported module\n      // this implementation is not 100% perfect for weird media query combinations\n      // when a module is imported multiple times with different media queries.\n      // I hope this will never occur (Hey this way we have smaller bundles)\n\n      if (item[0] == null || !alreadyImportedModules[item[0]]) {\n        if (mediaQuery && !item[2]) {\n          item[2] = mediaQuery;\n        } else if (mediaQuery) {\n          item[2] = \"(\".concat(item[2], \") and (\").concat(mediaQuery, \")\");\n        }\n\n        list.push(item);\n      }\n    }\n  };\n\n  return list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring\n\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (useSourceMap && typeof btoa === 'function') {\n    var sourceMapping = toComment(cssMapping);\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return \"/*# sourceURL=\".concat(cssMapping.sourceRoot).concat(source, \" */\");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n  }\n\n  return [content].join('\\n');\n} // Adapted from convert-source-map (MIT)\n\n\nfunction toComment(sourceMap) {\n  // eslint-disable-next-line no-undef\n  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n  var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n  return \"/*# \".concat(data, \" */\");\n}\n\n//# sourceURL=webpack://tetris/./node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/getUrl.js":
/*!********************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/getUrl.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function (url, needQuotes) {\n  // eslint-disable-next-line no-underscore-dangle, no-param-reassign\n  url = url.__esModule ? url.default : url;\n\n  if (typeof url !== 'string') {\n    return url;\n  } // If url is already wrapped in quotes, remove them\n\n\n  if (/^['\"].*['\"]$/.test(url)) {\n    // eslint-disable-next-line no-param-reassign\n    url = url.slice(1, -1);\n  } // Should url be wrapped?\n  // See https://drafts.csswg.org/css-values-3/#urls\n\n\n  if (/[\"'() \\t\\n]/.test(url) || needQuotes) {\n    return \"\\\"\".concat(url.replace(/\"/g, '\\\\\"').replace(/\\n/g, '\\\\n'), \"\\\"\");\n  }\n\n  return url;\n};\n\n//# sourceURL=webpack://tetris/./node_modules/css-loader/dist/runtime/getUrl.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _tetris_tetris_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tetris/tetris.css */ \"./src/tetris/tetris.css\");\n/* harmony import */ var _tetris_tetris_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tetris_tetris_css__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils_fragmenttext_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/fragmenttext.js */ \"./src/utils/fragmenttext.js\");\n/* harmony import */ var _utils_fragmenttext_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_utils_fragmenttext_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _tetris_sound_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tetris/sound.js */ \"./src/tetris/sound.js\");\n/* harmony import */ var _tetris_color_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tetris/color.js */ \"./src/tetris/color.js\");\n/* harmony import */ var _tetris_brick_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tetris/brick.js */ \"./src/tetris/brick.js\");\n/* harmony import */ var _tetris_game_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./tetris/game.js */ \"./src/tetris/game.js\");\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  TetrisGame: _tetris_game_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]\n});\n\n//# sourceURL=webpack://tetris/./src/index.js?");

/***/ }),

/***/ "./src/tetris/brick.js":
/*!*****************************!*\
  !*** ./src/tetris/brick.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _sound_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sound.js */ \"./src/tetris/sound.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\nvar Brick =\n/*#__PURE__*/\nfunction () {\n  function Brick(options) {\n    _classCallCheck(this, Brick);\n\n    var o = options || {\n      'ingame': false,\n      'game': null\n    };\n    this.game = o.game;\n    this.ingame = o.ingame;\n    var x;\n    var y;\n    Object.defineProperties(this, {\n      \"x\": {\n        get: function get() {\n          return x;\n        },\n        set: function set(v) {\n          x = v;\n\n          if (this.ingame && this.game != null) {\n            this.game.PENDINGUPDATE = true;\n          }\n        }\n      },\n      \"y\": {\n        get: function get() {\n          return y;\n        },\n        set: function set(v) {\n          y = v;\n\n          if (this.ingame && this.game != null) {\n            this.game.PENDINGUPDATE = true;\n          }\n        }\n      }\n    });\n\n    if (this.ingame) {\n      var brfrm = this.game.bricksform;\n      var rnd = this.game.nextRandom;\n      this.color = this.game.getColors()[rnd].copy();\n      this.blocks = brfrm[rnd].concat();\n      this.moving = true;\n      this.x = Math.round(this.game.getWIDTH() / 2 - this.blocks[0].length / 2);\n      this.y = Math.round(0 - this.blocks.length);\n      this.game.nextRandom = Math.round(Math.random() * (brfrm.length - 1));\n    }\n  }\n\n  _createClass(Brick, [{\n    key: \"resetPosition\",\n    value: function resetPosition() {\n      this.x = Math.round(this.game.getWIDTH() / 2 - this.blocks[0].length / 2);\n      this.y = Math.round(0 - this.blocks.length);\n    }\n  }, {\n    key: \"checkCollision\",\n    value: function checkCollision(x, y, brcks) {\n      for (var i in brcks) {\n        for (var i1 in brcks[i].blocks) {\n          for (var i2 in brcks[i].blocks[i1]) {\n            if (brcks[i].blocks[i1][i2] == 1) {\n              var cond1 = x == brcks[i].x + parseInt(i2);\n              var cond2 = y == brcks[i].y + parseInt(i1);\n              var cond3 = this != brcks[i];\n\n              if (cond1 && cond2 && cond3) {\n                return false;\n              } else {}\n            }\n          }\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"getHeight\",\n    value: function getHeight() {\n      var height = 0;\n\n      for (var i1 in this.blocks) {\n        for (var i2 in this.blocks[i1]) {\n          if (this.blocks[i1][i2] == 1) {\n            height = Math.max(height, parseInt(i1) + 1);\n          }\n        }\n      }\n\n      return height;\n    }\n  }, {\n    key: \"getWidth\",\n    value: function getWidth() {\n      var high = 0;\n      var // 1E309 = infinity\n      low = 1E309;\n      var countrow = 0;\n\n      for (var i1 in this.blocks) {\n        countrow = 0;\n\n        for (var i2 in this.blocks[i1]) {\n          if (this.blocks[i1][i2] == 1) {\n            high = Math.max(high, parseInt(i2) + 2);\n            low = Math.min(low, parseInt(i2) + 2);\n            countrow++;\n          }\n        }\n      }\n\n      return high - low + 1;\n    }\n  }, {\n    key: \"getBlockY\",\n    value: function getBlockY() {\n      var cnt = 0;\n      var rtn = 0;\n\n      for (var i1 in this.blocks) {\n        for (var i2 in this.blocks[i1]) {\n          if (this.blocks[i1][i2] == 0) {\n            cnt++;\n          }\n        }\n\n        if (cnt == this.blocks[0].length) {\n          rtn++;\n        } else {\n          return rtn;\n        }\n      }\n    }\n  }, {\n    key: \"getBlockX\",\n    value: function getBlockX() {\n      var cnt = 0;\n      var rtn = 0;\n\n      for (var i = 0; i < 4; i++) {\n        cnt = 0;\n\n        for (var i1 in this.blocks) {\n          if (this.blocks[i1][i] == 0) {\n            cnt++;\n          }\n        }\n\n        if (cnt == this.blocks.length) {\n          rtn++;\n        } else {\n          return rtn;\n        }\n      }\n    }\n  }, {\n    key: \"rotate_okay\",\n    value: function rotate_okay(brick, bl) {\n      for (var i1 in bl) {\n        for (var i2 in bl[i1]) {\n          if (bl[i1][i2] == 1) {\n            if (brick.checkCollision(brick.x + parseInt(i2), brick.y + parseInt(i1), this.game.bricks) == false || brick.y + Brick.emulate(bl).getHeight() >= this.game.HEIGHT || brick.x + Brick.emulate(bl).getWidth() + Brick.emulate(bl).getBlockX() > this.game.getWIDTH() || brick.x + Brick.emulate(bl).getBlockX() < 0) {\n              return false;\n            }\n          }\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"rotate\",\n    value: function rotate(way) {\n      if (this.game.getRUNNING()) {\n        var blocks2 = [];\n        var w = this.blocks[0].length;\n        var h = this.blocks.length;\n        var x;\n        var y;\n        var row;\n\n        for (y = 0; y < h; y++) {\n          row = [];\n\n          for (x = 0; x < w; x++) {\n            row[x] = this.blocks[w - x - 1][y];\n          }\n\n          blocks2[y] = row;\n        }\n\n        if (this.rotate_okay(this, blocks2)) {\n          //yeah\n          if (this.ingame && this.game != null) {\n            this.game.PENDINGUPDATE = true;\n          }\n        } else {\n          if (this.x + Brick.emulate(blocks2).getWidth() + Brick.emulate(blocks2).getBlockX() > this.game.getWIDTH()) {\n            this.x--;\n\n            if (this.rotate_okay(this, blocks2)) {\n              // yeah\n              if (this.ingame && this.game != null) {\n                this.game.PENDINGUPDATE = true;\n              }\n            } else {\n              this.x++;\n              return false;\n            }\n          } else if (this.x + Brick.emulate(blocks2).getBlockX() < 0) {\n            this.x++;\n\n            if (this.rotate_okay(this, blocks2)) {\n              //yeah\n              if (this.ingame && this.game != null) {\n                this.game.PENDINGUPDATE = true;\n              }\n            } else {\n              this.x--;\n              return false;\n            }\n          } else {\n            return false;\n          }\n        }\n\n        this.blocks = blocks2;\n      }\n    }\n  }, {\n    key: \"moveleft\",\n    value: function moveleft() {\n      if (this.game.getRUNNING()) {\n        Object(_sound_js__WEBPACK_IMPORTED_MODULE_0__[\"playSound\"])(\"gamemove\");\n        var may_i_fall = true;\n\n        if (this.moving) {\n          for (var i1 in this.blocks) {\n            for (var i2 in this.blocks[i1]) {\n              if (this.blocks[i1][i2] == 1) {\n                if (this.checkCollision(this.x + parseInt(i2) - 1, this.y + parseInt(i1), this.game.bricks) == false || this.x + this.getBlockX() <= 0) {\n                  may_i_fall = false;\n                }\n              }\n            }\n          }\n\n          if (may_i_fall) {\n            this.x--;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"moveright\",\n    value: function moveright() {\n      if (this.game.getRUNNING()) {\n        Object(_sound_js__WEBPACK_IMPORTED_MODULE_0__[\"playSound\"])(\"gamemove\");\n        var may_i_fall = true;\n\n        if (this.moving) {\n          for (var i1 in this.blocks) {\n            for (var i2 in this.blocks[i1]) {\n              if (this.blocks[i1][i2] == 1) {\n                if (this.checkCollision(this.x + parseInt(i2) + 1, this.y + parseInt(i1), this.game.bricks) == false || this.x + this.getWidth() + this.getBlockX() >= this.game.getWIDTH()) {\n                  may_i_fall = false;\n                }\n              }\n            }\n          }\n\n          if (may_i_fall) {\n            this.x++;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"smashdown\",\n    value: function smashdown() {\n      if (this.game.getRUNNING() && this.game.MAYDROP) {\n        Object(_sound_js__WEBPACK_IMPORTED_MODULE_0__[\"playSound\"])(\"gamebump\");\n        this.moving = false;\n        this.y = this.getLowestPosition(this.game.bricks);\n        this.game.PENDINGUPDATE = true;\n\n        if (this.y + this.getBlockY() >= 0) {\n          var sliced = this.slice_up();\n          this.game.bricks.splice(this.findMe(), 1);\n\n          for (var i in sliced) {\n            this.game.bricks.push(sliced[i]);\n          }\n\n          this.game.checkLines();\n          this.game.bricks.push(new Brick({\n            ingame: true,\n            game: this.game\n          }));\n          this.game.HOLDINGCOUNT = 0;\n        } else {\n          menuNav(\"gamelose\");\n          Object(_sound_js__WEBPACK_IMPORTED_MODULE_0__[\"playSound\"])(\"gamelose\");\n        }\n\n        this.game.MAYDROP = false;\n      }\n    }\n  }, {\n    key: \"movedown\",\n    value: function movedown() {\n      if (this.game.getRUNNING()) {\n        var i;\n        var may_i_fall = true;\n\n        if (this.moving) {\n          for (var i1 in this.blocks) {\n            for (var i2 in this.blocks[i1]) {\n              if (this.blocks[i1][i2] == 1) {\n                if (this.checkCollision(this.x + parseInt(i2), this.y + parseInt(i1) + 1, this.game.bricks) == false || this.y + this.getHeight() >= this.game.HEIGHT) {\n                  may_i_fall = false;\n                }\n              }\n            }\n          }\n\n          if (may_i_fall) {\n            this.y++;\n          } else {\n            this.moving = false;\n            Object(_sound_js__WEBPACK_IMPORTED_MODULE_0__[\"playSound\"])(\"gamebump\");\n\n            if (this.y + this.getBlockY() >= 0) {\n              var sliced = this.slice_up();\n              this.game.bricks.splice(this.findMe(), 1);\n\n              for (var i in sliced) {\n                this.game.bricks.push(sliced[i]);\n              }\n\n              this.game.checkLines();\n              this.game.bricks.push(new Brick({\n                ingame: true,\n                game: this.game\n              }));\n              this.game.HOLDINGCOUNT = 0;\n            } else {\n              menuNav(\"gamelose\");\n              Object(_sound_js__WEBPACK_IMPORTED_MODULE_0__[\"playSound\"])(\"gamelose\");\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"getLowestPosition\",\n    value: function getLowestPosition(br) {\n      var h = this.getHeight();\n      var this_x = this.x;\n      var this_y = this.y;\n      var stillgood = true;\n      var isgood = true;\n\n      while (stillgood) {\n        isgood = true;\n\n        for (var i1 in this.blocks) {\n          for (var i2 in this.blocks[i1]) {\n            if (this.blocks[i1][i2] == 1) {\n              if (this.checkCollision(this_x + parseInt(i2), this_y + parseInt(i1), br) == false || this_y + h > this.game.HEIGHT) {\n                isgood = false;\n              } else {}\n            }\n          }\n        }\n\n        if (isgood == true) {\n          this_y++;\n        } else {\n          stillgood = false;\n        }\n      }\n\n      return this_y - 1;\n    }\n  }, {\n    key: \"slice_up\",\n    value: function slice_up() {\n      var rtn = [];\n      var i;\n      var i1;\n      var i2;\n      var this_color = this.color;\n\n      for (var i1 in this.blocks) {\n        for (var i2 in this.blocks[i1]) {\n          if (this.blocks[i1][i2] == 1) {\n            rtn.push(function (x, y) {\n              var tmp = new Brick();\n              tmp.moving = false;\n              tmp.blocks = [[1]];\n              tmp.color = this_color;\n              tmp.x = x;\n              tmp.y = y;\n              return tmp;\n            }(parseInt(i2) + this.x, parseInt(i1) + this.y));\n          }\n        }\n      }\n\n      return rtn;\n    }\n  }, {\n    key: \"findMe\",\n    value: function findMe() {\n      for (var i in this.game.bricks) {\n        if (this.game.bricks[i] == this) {\n          return i;\n        }\n      }\n\n      return -1;\n    }\n  }]);\n\n  return Brick;\n}();\n\nBrick.emulate = function (vblocks) {\n  var tmp = new Brick({\n    ingame: false,\n    game: null\n  });\n  tmp.moving = false;\n  tmp.blocks = vblocks;\n  return tmp;\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Brick);\n\n//# sourceURL=webpack://tetris/./src/tetris/brick.js?");

/***/ }),

/***/ "./src/tetris/color.js":
/*!*****************************!*\
  !*** ./src/tetris/color.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Color =\n/*#__PURE__*/\nfunction () {\n  function Color(r, g, b, a) {\n    _classCallCheck(this, Color);\n\n    this.r = r; // Red\n\n    this.g = g; // Green\n\n    this.b = b; // Blue\n\n    this.a = a; // Alpha\n  }\n\n  _createClass(Color, [{\n    key: \"add\",\n    value: function add(_r, _g, _b, _a) {\n      return new Color(Math.min(255, this.r + _r), this.g + _g, this.b + _b, this.a + _a);\n    }\n  }, {\n    key: \"toRGBAString\",\n    value: function toRGBAString() {\n      return \"rgba(\".concat(parseInt(this.r), \",\").concat(parseInt(this.g), \",\").concat(parseInt(this.b), \",\").concat(parseFloat(this.a), \")\");\n    }\n  }, {\n    key: \"copy\",\n    value: function copy() {\n      return new Color(this.r, this.g, this.b, this.a);\n    }\n  }]);\n\n  return Color;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Color);\n\n//# sourceURL=webpack://tetris/./src/tetris/color.js?");

/***/ }),

/***/ "./src/tetris/game.js":
/*!****************************!*\
  !*** ./src/tetris/game.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ \"./src/tetris/color.js\");\n/* harmony import */ var _brick_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./brick.js */ \"./src/tetris/brick.js\");\n/* harmony import */ var _sound_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./sound.js */ \"./src/tetris/sound.js\");\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\nvar TetrisGame =\n/*#__PURE__*/\nfunction () {\n  function TetrisGame() {\n    _classCallCheck(this, TetrisGame);\n\n    var // [number] Bricks x count\n    WIDTH;\n    var // [number] Bricks y count\n    HEIGHT;\n    var // [number] Size of a brick (in pixels)\n    BRICKSIZE;\n    var // [number] Width of grid\n    GRID_WIDTH;\n    var // [number] Height of grid\n    GRID_HEIGHT;\n    var // [number] canvas width (soon to be deleted)\n    CANVAS_WIDTH;\n    var // [number] canvas height (soon to be deleted)\n    CANVAS_HEIGHT;\n    var // [number] FPS counter\n    FPS = 0;\n    var // [Bool] Update to graphic\n    PENDINGUPDATE = false;\n    var // [string] Font name\n    GRAPHIC_FONT;\n    var // [number] Menu font size\n    GRAPHIC_MENU_FONTSIZE;\n    var // [number] Menu subtext font size\n    GRAPHIC_MENUDESC_FONTSIZE;\n    var // [number] Menu ???\n    GRAPHIC_MENU_DISTANCE;\n    var // [number] Board font size\n    GRAPHIC_BOARD_FONTSIZE;\n    var // [number] Score font size\n    GRAPHIC_SCORE_FONTSIZE;\n    var // [bool] running\n    RUNNING = true;\n    var // [Graphic Context] Game 2d context\n    ctx;\n    var // [Graphic Context] Game holding brick 2d context\n    h_ctx;\n    var // [Graphic Context] Game next brick 2d context\n    n_ctx;\n    var // [number] Current showing screen\n    WHERE = -1;\n    var // 0 = menu\n    // 1 = ingame\n    // 2 = paused\n    // 3 = tutorial\n    // 4 = about\n    // 5 = lost game\n    // 6 = Settings\n    // [number] Unused (might be removed)\n    FROM = 0;\n    var // [number/bool] If webaudio doesnt work, then skip download\n    webAudioApiFailed = 0;\n    var // [number] Selected menu item\n    SELECTED_MENU = 0;\n    var // [bool] ghost option\n    SETTING_GHOST = true;\n    var // [Brick] current holding brick\n    HOLDING = null;\n    var // count of holding\n    HOLDINGCOUNT = 0;\n    var scoreelement = null;\n    var // Fix to avoid Space to repeat keydown events\n    MAYDROP = true;\n    var SCORE = 0;\n    var bricks = [];\n    var bricksform = [[[0, 1, 0], [0, 1, 0], [0, 1, 1]], [[0, 1, 0], [0, 1, 0], [1, 1, 0]], [[0, 1, 1], [1, 1, 0], [0, 0, 0]], [[1, 1, 0], [0, 1, 1], [0, 0, 0]], [[0, 1, 0], [1, 1, 1], [0, 0, 0]], [[1, 1], [1, 1]], [[0, 1, 0, 0], [0, 1, 0, 0], [0, 1, 0, 0], [0, 1, 0, 0]]];\n    var colors = [new _color_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](255, 0, 0, 1), new _color_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](0, 255, 0, 1), new _color_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](0, 0, 255, 1), new _color_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](255, 255, 0, 1), new _color_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](0, 255, 255, 1), new _color_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](255, 0, 255, 1), new _color_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](0, 128, 128, 1)];\n    var nextRandom = Math.round(Math.random() * (bricksform.length - 1));\n\n    function setScore(v) {\n      SCORE = v;\n      scoreelement.innerHTML = SCORE;\n    }\n\n    Object.defineProperties(this, {\n      \"bricks\": {\n        get: function get() {\n          return bricks;\n        },\n        set: function set(v) {\n          if (v == \"\" && _typeof([]) == \"object\") {\n            setScore(0);\n            HOLDINGCOUNT = 0;\n            HOLDING = null;\n            bricks = [];\n          } else {\n            return false;\n          }\n        }\n      },\n      \"WIDTH\": {\n        get: function get() {\n          return WIDTH;\n        },\n        set: function set(v) {\n          return false;\n        }\n      },\n      \"HEIGHT\": {\n        get: function get() {\n          return HEIGHT;\n        },\n        set: function set(v) {\n          return false;\n        }\n      },\n      \"HOLDINGCOUNT\": {\n        get: function get() {\n          return HOLDINGCOUNT;\n        },\n        set: function set(v) {\n          HOLDINGCOUNT = v;\n        }\n      },\n      \"PENDINGUPDATE\": {\n        get: function get() {\n          return PENDINGUPDATE;\n        },\n        set: function set(v) {\n          PENDINGUPDATE = v;\n        }\n      },\n      \"nextRandom\": {\n        get: function get() {\n          return nextRandom;\n        },\n        set: function set(v) {\n          nextRandom = v;\n        }\n      },\n      \"MAYDROP\": {\n        get: function get() {\n          return MAYDROP;\n        },\n        set: function set(v) {\n          MAYDROP = v;\n        }\n      }\n    });\n\n    this.getBricksform = function () {\n      return bricksform;\n    };\n\n    this.getColors = function () {\n      return colors;\n    }; //this.getMAYDROP=function () { return MAYDROP; };\n\n\n    this.getRUNNING = function () {\n      return RUNNING;\n    };\n\n    this.getWIDTH = function () {\n      return WIDTH;\n    };\n\n    this.bricksform = bricksform;\n\n    function checkXY(x, y) {\n      var bri_len;\n      var blo_len;\n      var brl_len;\n\n      for (var i = 0, _bri_len = bricks.length; i < _bri_len; i++) {\n        for (var j = 0, _blo_len = bricks[i].blocks.length; j < _blo_len; j++) {\n          for (var k = 0, _brl_len = bricks[i].blocks[j].length; k < _brl_len; k++) {\n            if (bricks[i].blocks[j][k] == 1) {\n              var cond1 = x == bricks[i].x + parseInt(k);\n              var cond2 = y == bricks[i].y + parseInt(j);\n              var cond3 = bricks[i].moving == false;\n\n              if (cond1 && cond2 && cond3) {\n                return true;\n              }\n            }\n          }\n        }\n      }\n\n      return false;\n    }\n\n    function clearLine(l) {\n      if (RUNNING) {\n        setScore(SCORE + 1);\n        Object(_sound_js__WEBPACK_IMPORTED_MODULE_2__[\"playSound\"])(\"gamerow\");\n\n        var toDelete = function (line) {\n          var rtn = [];\n          var tx = 0;\n          var times = 0;\n\n          for (times = 0; times <= WIDTH; times++) {\n            for (var i in bricks) {\n              for (var i1 in bricks[i].blocks) {\n                for (var i2 in bricks[i].blocks[i1]) {\n                  if (bricks[i].blocks[i1][i2] == 1) {\n                    var cond1 = line == bricks[i].y + parseInt(i1);\n                    var cond2 = bricks[i].moving == false;\n\n                    if (cond1 && cond2) {\n                      bricks.splice(parseInt(i), 1);\n                    }\n                  }\n                }\n              }\n            }\n          }\n\n          return rtn;\n        }(l);\n\n        var movedown = function (line) {\n          var rtn = [];\n          var tx = 0;\n          var times = 0;\n\n          for (var i in bricks) {\n            for (var i1 in bricks[i].blocks) {\n              for (var i2 in bricks[i].blocks[i1]) {\n                if (bricks[i].blocks[i1][i2] == 1) {\n                  var cond1 = line > bricks[i].y + parseInt(i1);\n                  var cond2 = bricks[i].moving == false;\n\n                  if (cond1 && cond2) {\n                    bricks[i].y++;\n                  }\n                }\n              }\n            }\n          }\n\n          return rtn;\n        }(l);\n      }\n    }\n\n    this.checkLines = function () {\n      //check for full lines\n      if (RUNNING) {\n        var cx;\n\n        for (var i = HEIGHT; i > 1; i--) {\n          var cnt = 0;\n\n          for (cx = 0; cx <= WIDTH - 1; cx++) {\n            if (checkXY(cx, i)) {\n              cnt++;\n            }\n          }\n\n          if (cnt == WIDTH) {\n            clearLine(i++);\n          }\n        }\n\n        PENDINGUPDATE = true;\n      }\n    };\n\n    function makeBrick(ctx, x, y, w, h, _ref) {\n      var r = _ref.r,\n          g = _ref.g,\n          b = _ref.b,\n          a = _ref.a;\n      var fstyle = ctx.createRadialGradient(x + w / 2, y + h / 2, 0, x + w / 2, y + h / 2, 40);\n      fstyle.addColorStop(0, new _color_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](r, g, b, a).toRGBAString());\n      fstyle.addColorStop(1, new _color_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](r, g, b, a * 0.5).toRGBAString());\n      ctx.fillStyle = fstyle;\n      ctx.fillRect(x, y, w, h);\n      var fstyle = ctx.createLinearGradient(x + w / 2, y, x + w / 2, y + h);\n      fstyle.addColorStop(0.2, new _color_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](r, g, b, 0.5).toRGBAString());\n      fstyle.addColorStop(0, new _color_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](0, 0, 0, 0.9).toRGBAString());\n      ctx.fillStyle = fstyle;\n      ctx.fillRect(x, y, w, h);\n      var fstyle = ctx.createLinearGradient(x, y + h / 2, x + w, y + h / 2);\n      fstyle.addColorStop(0.3, new _color_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](r * 0.7, g * 0.7, b * 0.7, 0).toRGBAString());\n      fstyle.addColorStop(0, new _color_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](0, 0, 0, 0.4).toRGBAString());\n      ctx.fillStyle = fstyle;\n      ctx.fillRect(x, y, w, h);\n      var fstyle = ctx.createLinearGradient(x + w / 2, y, x + w / 2, y + h);\n      fstyle.addColorStop(0.8, new _color_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](r * 0.1, g * 0.1, b * 0.1, 0).toRGBAString());\n      fstyle.addColorStop(1, new _color_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](0, 0, 0, 1).toRGBAString());\n      ctx.fillStyle = fstyle;\n      ctx.fillRect(x, y, w, h);\n      var fstyle = ctx.createLinearGradient(x, y + h / 2, x + w, y + h / 2);\n      fstyle.addColorStop(0.8, new _color_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](r * 0.2, g * 0.2, b * 0.2, 0).toRGBAString());\n      fstyle.addColorStop(1, new _color_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](0, 0, 0, 1).toRGBAString());\n      ctx.fillStyle = fstyle;\n      ctx.fillRect(x, y, w, h);\n    }\n\n    function getMovingBrick() {\n      var i;\n\n      for (var i in bricks) {\n        if (bricks[i].moving) {\n          return bricks[i];\n        }\n      }\n    }\n\n    function holdingShift() {\n      if (HOLDINGCOUNT < 1) {\n        if (HOLDING == null) {\n          HOLDING = getMovingBrick();\n          bricks[getMovingBrick().findMe()] = new _brick_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n            ingame: true,\n            game: getMovingBrick().game\n          });\n          HOLDINGCOUNT++;\n        } else {\n          var HOLDING2 = HOLDING;\n          HOLDING = getMovingBrick();\n          HOLDING2.resetPosition();\n          bricks[getMovingBrick().findMe()] = HOLDING2;\n          HOLDINGCOUNT++;\n        }\n      }\n    }\n\n    function clearAndResize(ctx) {\n      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n      ctx.canvas.width = CANVAS_WIDTH;\n      ctx.canvas.height = CANVAS_HEIGHT;\n      h_ctx.clearRect(0, 0, h_ctx.canvas.width, h_ctx.canvas.height);\n      h_ctx.canvas.width = BRICKSIZE * 4;\n      h_ctx.canvas.height = BRICKSIZE * 4;\n      n_ctx.clearRect(0, 0, n_ctx.canvas.width, n_ctx.canvas.height);\n      n_ctx.canvas.width = BRICKSIZE * 4;\n      n_ctx.canvas.height = BRICKSIZE * 4;\n    }\n\n    function tiles(ctx) {\n      // Grid\n      return 0;\n      var ix = 0;\n      var iy = 0;\n      ctx.lineWidth = 1;\n      ctx.strokeStyle = \"rgba(0,255,0,0.5)\";\n      ctx.fillStyle = \"white\";\n\n      for (var ix = 0; ix <= GRID_WIDTH; ix += BRICKSIZE) {\n        ctx.beginPath();\n        ctx.lineTo(ix, 0);\n        ctx.lineTo(ix, GRID_HEIGHT);\n        ctx.closePath();\n        ctx.stroke();\n      }\n\n      for (var iy = 0; iy <= GRID_HEIGHT; iy += BRICKSIZE) {\n        ctx.beginPath();\n        ctx.lineTo(0, iy);\n        ctx.lineTo(GRID_WIDTH, iy);\n        ctx.closePath();\n        ctx.stroke();\n      }\n    }\n\n    function inGameGraphic(ctx) {\n      clearAndResize(ctx);\n      tiles(ctx);\n\n      for (var i in bricks) {\n        if (SETTING_GHOST) {\n          if (bricks[i].moving) {\n            //ctx.fillStyle=\"rgba(255,255,255,0.5)\";\n            var tmp_lowestPos = bricks[i].getLowestPosition(bricks);\n\n            for (var i1 in bricks[i].blocks) {\n              for (var i2 in bricks[i].blocks[i1]) {\n                if (bricks[i].blocks[i1][i2] == 1) {\n                  if (tmp_lowestPos * BRICKSIZE + parseInt(i1) * BRICKSIZE >= 0 && bricks[i].y * BRICKSIZE + parseInt(i1) * BRICKSIZE <= GRID_HEIGHT) {\n                    makeBrick(ctx, bricks[i].x * BRICKSIZE + parseInt(i2) * BRICKSIZE, tmp_lowestPos * BRICKSIZE + parseInt(i1) * BRICKSIZE, BRICKSIZE, BRICKSIZE, new _color_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](255, 255, 255, 0.2));\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        for (var i1 in bricks[i].blocks) {\n          for (var i2 in bricks[i].blocks[i1]) {\n            if (bricks[i].blocks[i1][i2] == 1) {\n              if (bricks[i].y * BRICKSIZE + parseInt(i1) * BRICKSIZE >= 0 && bricks[i].y * BRICKSIZE + parseInt(i1) * BRICKSIZE <= GRID_HEIGHT) {\n                makeBrick(ctx, bricks[i].x * BRICKSIZE + parseInt(i2) * BRICKSIZE, bricks[i].y * BRICKSIZE + parseInt(i1) * BRICKSIZE, BRICKSIZE, BRICKSIZE, bricks[i].color);\n              }\n            }\n          }\n        }\n      } // NextBox field\n\n\n      var BRICKSIZESCALE = 1.5;\n      var nextBrickX = BRICKSIZE / BRICKSIZESCALE * 2;\n      var nextBrickY = BRICKSIZE / BRICKSIZESCALE * 2;\n\n      for (var i1 in bricksform[nextRandom]) {\n        for (var i2 in bricksform[nextRandom][i1]) {\n          if (bricksform[nextRandom][i1][i2] == 1) {\n            makeBrick(n_ctx, nextBrickX + parseInt(i2) * (BRICKSIZE / BRICKSIZESCALE), nextBrickY + parseInt(i1) * (BRICKSIZE / BRICKSIZESCALE), BRICKSIZE / BRICKSIZESCALE, BRICKSIZE / BRICKSIZESCALE, colors[nextRandom]);\n          }\n        }\n      } // HoldingField\n\n\n      h_ctx.lineWidth = 1;\n      h_ctx.strokeStyle = \"rgba(0,255,0,0.5)\";\n      h_ctx.fillStyle = \"white\";\n      var holdBrickX = 0;\n      var holdBrickY = 0;\n\n      if (HOLDING != null) {\n        for (var i1 in HOLDING.blocks) {\n          for (var i2 in HOLDING.blocks[i1]) {\n            if (HOLDING.blocks[i1][i2] == 1) {\n              makeBrick(h_ctx, holdBrickX + parseInt(i2) * (BRICKSIZE / BRICKSIZESCALE), holdBrickY + parseInt(i1) * (BRICKSIZE / BRICKSIZESCALE), BRICKSIZE / BRICKSIZESCALE, BRICKSIZE / BRICKSIZESCALE, HOLDING.color);\n            }\n          }\n        }\n      }\n    }\n\n    var GAMECONTROLDOWN = false;\n    var MOVESPEED = 1000;\n\n    function gameControlDown() {\n      if (GAMECONTROLDOWN == false) {\n        var func = function func() {\n          GAMECONTROLDOWN = true;\n\n          if (WHERE == 1) {\n            getMovingBrick().movedown();\n            setTimeout(func, MOVESPEED);\n          } else {\n            GAMECONTROLDOWN = false;\n          }\n        };\n\n        func();\n      }\n    }\n\n    function keyh(e) {\n      switch (e.keyCode) {\n        case 37:\n        case 38:\n        case 39:\n        case 40:\n        case 32:\n          e.preventDefault();\n\n          if (RUNNING) {\n            // 32 = space brick.smashdown()\n            // 37 = left brick.moveleft()\n            // 38 = up brick.rotate()\n            // 39 = right brick.moveright()\n            // 40 = down brick.movedown()\n            getMovingBrick()[Array(32).concat(\"smashdown\", Array(4)).concat(\"moveleft,rotate,moveright,movedown\".split(\",\"))[e.keyCode]]();\n          }\n\n          break;\n\n        case 27:\n          // escape\n          e.preventDefault();\n\n          if (RUNNING) {\n            // ingame\n            menuNav(\"paused\");\n            Object(_sound_js__WEBPACK_IMPORTED_MODULE_2__[\"playSound\"])(\"menuback\");\n          }\n\n          break;\n\n        case 16:\n          // shift\n          e.preventDefault();\n\n          if (RUNNING) {\n            holdingShift();\n          }\n\n          break;\n      }\n    }\n\n    function keyup(_ref2) {\n      var keyCode = _ref2.keyCode;\n      if (keyCode == 32) MAYDROP = true;\n    }\n\n    function graphicControlLoop() {\n      // CTX GRAPHICS\n      requestAnimationFrame(graphicControlLoop);\n\n      if (PENDINGUPDATE) {\n        inGameGraphic(ctx);\n        PENDINGUPDATE = false;\n      }\n    }\n\n    this.init = function (g, h, n, sc) {\n      WIDTH = 10;\n      HEIGHT = 20;\n      BRICKSIZE = 30;\n      CANVAS_WIDTH = BRICKSIZE * WIDTH;\n      CANVAS_HEIGHT = BRICKSIZE * HEIGHT;\n      GRID_WIDTH = WIDTH * BRICKSIZE;\n      GRID_HEIGHT = HEIGHT * BRICKSIZE;\n      GRAPHIC_FONT = \"Verdana\";\n      GRAPHIC_MENU_FONTSIZE = BRICKSIZE * 0.75;\n      GRAPHIC_MENUDESC_FONTSIZE = BRICKSIZE;\n      GRAPHIC_MENU_DISTANCE = GRAPHIC_MENU_FONTSIZE * 1.5;\n      GRAPHIC_BOARD_FONTSIZE = BRICKSIZE - 5;\n      GRAPHIC_SCORE_FONTSIZE = BRICKSIZE;\n      WHERE = 1;\n      RUNNING = true;\n      bricks = [];\n      scoreelement = sc;\n      setScore(0);\n      HOLDINGCOUNT = 0;\n      HOLDING = null;\n      bricks.push(new _brick_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n        ingame: true,\n        game: this\n      }));\n      gameControlDown();\n      window.addEventListener(\"keydown\", keyh, false);\n      window.addEventListener(\"keyup\", keyup, false);\n      ctx =\n      /*document.querySelector(\"canvas#game\")*/\n      g.getContext(\"2d\");\n      h_ctx =\n      /*document.querySelector(\"canvas#holding\")*/\n      h.getContext(\"2d\");\n      n_ctx =\n      /*document.querySelector(\"canvas#next\")*/\n      n.getContext(\"2d\");\n      clearAndResize(ctx);\n      graphicControlLoop();\n    };\n  }\n\n  _createClass(TetrisGame, [{\n    key: \"bricksform\",\n    get: function get() {\n      return this._value;\n    },\n    set: function set(val) {\n      this._value = val;\n    }\n  }]);\n\n  return TetrisGame;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (TetrisGame);\n\n//# sourceURL=webpack://tetris/./src/tetris/game.js?");

/***/ }),

/***/ "./src/tetris/grid.svg":
/*!*****************************!*\
  !*** ./src/tetris/grid.svg ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"33852cc8d92f25f4a7c6517b548b2eae.svg\";\n\n//# sourceURL=webpack://tetris/./src/tetris/grid.svg?");

/***/ }),

/***/ "./src/tetris/sound.js":
/*!*****************************!*\
  !*** ./src/tetris/sound.js ***!
  \*****************************/
/*! exports provided: playSound */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"playSound\", function() { return playSound; });\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nwindow.addEventListener('load', init, false);\nvar SOUNDS;\nvar playMusic;\nvar context;\nvar soundReady = false;\n\nfunction init() {\n  try {\n    var loadSound = function loadSound(id, url) {\n      if (context == false) {\n        return false;\n      }\n\n      var request = new XMLHttpRequest();\n      request.open('GET', url, true);\n      request.responseType = 'arraybuffer';\n      var idd = id; // Decode asynchronously\n\n      request.onprogress = function (_ref) {\n        var loaded = _ref.loaded,\n            total = _ref.total;\n        return;\n        (function (ed) {\n          for (var i in SOUNDS) {\n            if (SOUNDS[i][0] == ed) {\n              return SOUNDS[i];\n            }\n          }\n          /*for (var i in MUSIC) {\r\n          \tif (MUSIC[i][0] == ed) {\r\n          \t\treturn MUSIC[i];\r\n          \t}\r\n          }*/\n\n        })(idd)[2] = (id, loaded / total);\n      };\n\n      request.onload = function () {\n        context.decodeAudioData(request.response, function (buffer) {\n          _audioBuffers[id] = buffer; //playSound(buffer);\n\n          for (var i in SOUNDS) {\n            if (SOUNDS[i][2] != 1) {\n              return;\n            }\n          }\n\n          for (var i in MUSIC) {\n            if (MUSIC[i][2] != 1) {\n              return;\n            }\n          }\n\n          menuNav(\"menu\");\n        }, onError);\n      };\n\n      request.send();\n    };\n\n    var onError = function onError(e) {\n      console.error(e);\n    };\n\n    SOUNDS = [\"gamelose\", \"gamebump\", \"gamerow\", \"menuback\", \"gamemove\"]; //var context;\n\n    var _audioBuffers = [];\n    context = new AudioContext();\n    var currentMusicPlaying;\n    var toKill;\n\n    playMusic = function playMusic(id) {\n      // disabled sound.. i wanna hear music while making my tetris.. :)\n      return \"blah\";\n\n      if (settings_ch[0][2] != 1) {\n        return false;\n      }\n\n      if (context == false) {\n        return false;\n      }\n\n      try {\n        if (toKill != undefined) {\n          toKill.noteOff(0);\n          toKill.disconnect();\n        }\n\n        var source = context.createBufferSource(); // creates a sound source\n\n        source.loop = true;\n        source.buffer = _audioBuffers[id];\n        source.playbackRate.value = 1.0; // tell the source which sound to play\n\n        source.connect(context.destination); // connect the source to the context's destination (the speakers)\n\n        source.start(0); // play the source now\n\n        toKill = source;\n      } catch (e) {\n        console.log(e.message);\n        console.log(_typeof(_audioBuffers[id]));\n      }\n\n      ;\n    };\n\n    soundReady = true;\n\n    for (var i in SOUNDS) {\n      loadSound(SOUNDS[i], \"sound/\".concat(SOUNDS[i], \".wav\"));\n    }\n    /*for (var i in MUSIC) {\r\n    \tloadSound(MUSIC[i][0], MUSIC[i][1]);\r\n    }*/\n\n  } catch (e) {\n    console.error(e);\n    context = false;\n    webAudioApiFailed = 1;\n    WHERE = 0;\n\n    playSound = playMusic = function playMusic() {};\n  } //menuNav(\"menu\");\n\n}\n\nfunction playSound(id) {\n  if (soundReady !== true) return false;\n  /*if (settings_ch[0][2] != 1) {\r\n  \treturn false;\r\n  }*/\n\n  if (context == false) {\n    return false;\n  }\n\n  try {\n    var source = context.createBufferSource(); // creates a sound source\n\n    source.loop = false;\n    source.buffer = audioBuffers[id];\n    source.playbackRate.value = 1.0; // tell the source which sound to play\n\n    source.connect(context.destination); // connect the source to the context's destination (the speakers)\n\n    source.start(0); // play the source now\n\n    setTimeout(function () {\n      source.disconnect();\n    }, source.buffer.length / context.sampleRate * 1000 + 100);\n  } catch (e) {}\n\n  ;\n}\n\n//# sourceURL=webpack://tetris/./src/tetris/sound.js?");

/***/ }),

/***/ "./src/tetris/tetris.css":
/*!*******************************!*\
  !*** ./src/tetris/tetris.css ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\")(false);\n// Imports\nvar getUrl = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/getUrl.js */ \"./node_modules/css-loader/dist/runtime/getUrl.js\");\nvar ___CSS_LOADER_URL___0___ = getUrl(__webpack_require__(/*! ./grid.svg */ \"./src/tetris/grid.svg\"));\n// Module\nexports.push([module.i, \"body {\\r\\n\\tbackground-color:rgb(0,0,0);\\r\\n\\tmargin:50px 10px;\\r\\n\\ttext-align:center;\\r\\n\\tbackground: linear-gradient(rgb(200,200,200), rgb(123,123,123));\\r\\n}\\t\\r\\ncanvas#_1Go3wjpShhMJpTPzSRmtgs {\\r\\n\\tbackground: url(\" + ___CSS_LOADER_URL___0___ + \"), linear-gradient(rgb(100,100,100), rgb(80,80,80));\\r\\n\\tborder-radius: 5px;\\r\\n}\\r\\ncanvas#_1w6UBtO-WgXDHZqiOq3rbM {\\r\\n\\twidth: 120px;\\r\\n\\theight: 120px;\\r\\n\\tbackground: url(\" + ___CSS_LOADER_URL___0___ + \");\\r\\n\\tbackground-size: 20px;\\r\\n\\t/*background-color: #000;\\r\\n\\tvertical-align: top;\\r\\n\\tborder-radius: 20px;\\r\\n\\tbackground:linear-gradient(rgb(30,30,30), rgb(60,60,60));*/\\r\\n}\\r\\nspan._1w6UBtO-WgXDHZqiOq3rbM, span._2RPejQrsRHTxCJCLWyb_zK {\\r\\n\\tbackground-color: #000;\\r\\n\\tvertical-align: top;\\r\\n\\tborder-radius: 20px;\\r\\n\\tbackground: linear-gradient(#1E1E1E, #3C3C3C);\\r\\n}\\r\\nspan._1w6UBtO-WgXDHZqiOq3rbM p, span._2RPejQrsRHTxCJCLWyb_zK p, p._2PpNHKvHMglrdUTHP_aAla {\\r\\n\\tfont-family: sans-serif;\\r\\n\\tcolor: #FFF;\\r\\n\\tfont-weight: bold;\\r\\n\\tmargin: 10px 0px 0px 10px;\\r\\n}\\r\\n\\r\\n/* <p>Score: <span id=\\\"score\\\">0</span></p> */\\r\\np._2PpNHKvHMglrdUTHP_aAla {\\r\\n\\tmargin: 0px 0px 10px 0px;\\r\\n}\\r\\n\\r\\nspan._1w6UBtO-WgXDHZqiOq3rbM {\\r\\n\\tfloat: left;\\r\\n\\ttext-align: left;\\r\\n}\\r\\nspan._2RPejQrsRHTxCJCLWyb_zK {\\r\\n\\tfloat: right;\\r\\n\\ttext-align: left;\\r\\n}\\r\\ncanvas#_2RPejQrsRHTxCJCLWyb_zK {\\r\\n\\twidth: 120px;\\r\\n\\theight: 120px;\\r\\n\\tbackground: url(\" + ___CSS_LOADER_URL___0___ + \");\\r\\n\\tbackground-size: 20px;\\r\\n\\t/*background-color: #000;\\r\\n\\tvertical-align: top;\\r\\n\\tborder-radius: 20px;\\r\\n\\tbackground:linear-gradient(rgb(30,30,30), rgb(60,60,60));*/\\r\\n}\\r\\ndiv#_39Q81Xp2lyItNlw8PFBGfw {\\r\\n\\twidth:600px;\\r\\n\\tmargin:auto auto;\\r\\n\\tbackground:linear-gradient(rgb(50,50,50), rgb(60,60,60));\\r\\n\\tborder-radius: 50px;\\r\\n\\tpadding: 30px;\\r\\n}\\r\\nimg#_1GeBruR7dNXnbi7xQDq7h- {\\r\\n\\twidth:300px;\\r\\n\\theight:73px;\\r\\n\\tpadding-bottom: 10px;\\r\\n\\tanimation:_2dF_DICTdJqbJKn5Zbd4mf 1s ease-in-out infinite;\\r\\n\\t-webkit-animation:_2dF_DICTdJqbJKn5Zbd4mf 1s ease-in-out infinite;\\r\\n}\\r\\n\\r\\n@keyframes _2dF_DICTdJqbJKn5Zbd4mf { \\r\\n\\t0% { transform: rotate(-1.25deg); }\\r\\n\\t50% { transform: rotate(1.25deg); }\\r\\n\\t100% { transform: rotate(-1.25deg); }\\r\\n}\\r\\n\\r\\n@-webkit-keyframes _2dF_DICTdJqbJKn5Zbd4mf { \\r\\n\\t0% { -webkit-transform: rotate(-1.25deg); }\\r\\n\\t50% { -webkit-transform: rotate(1.25deg); }\\r\\n\\t100% { -webkit-transform: rotate(-1.25deg); }\\r\\n}\", \"\"]);\n// Exports\nexports.locals = {\n\t\"game\": \"_1Go3wjpShhMJpTPzSRmtgs\",\n\t\"holding\": \"_1w6UBtO-WgXDHZqiOq3rbM\",\n\t\"next\": \"_2RPejQrsRHTxCJCLWyb_zK\",\n\t\"scorelbl\": \"_2PpNHKvHMglrdUTHP_aAla\",\n\t\"container\": \"_39Q81Xp2lyItNlw8PFBGfw\",\n\t\"logo\": \"_1GeBruR7dNXnbi7xQDq7h-\",\n\t\"mymove\": \"_2dF_DICTdJqbJKn5Zbd4mf\"\n};\n\n//# sourceURL=webpack://tetris/./src/tetris/tetris.css?");

/***/ }),

/***/ "./src/utils/fragmenttext.js":
/*!***********************************!*\
  !*** ./src/utils/fragmenttext.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// FRAGMENTTEXT.JS\n// from http://codereview.stackexchange.com/questions/16081/splitting-text-into-lines-from-a-max-width-value-for-canvas \nfunction fragmentText(text, maxWidth, font) {\n  ctx.font = font;\n  var spacemeasure = ctx.measureText(\" \").width;\n  if (maxWidth < ctx.measureText(\"M\").width) // To prevent weird looping anamolies farther on.\n    throw \"Can't fragment less than one character.\";\n\n  if (ctx.measureText(text).width < maxWidth) {\n    return [text];\n  }\n\n  var words = text.split(' '),\n      metawords = [],\n      lines = []; // measure first.\n\n  for (var w in words) {\n    var word = words[w];\n    var measure = ctx.measureText(word).width; // Edge case - If the current word is too long for one line, break it into maximized pieces.\n\n    if (measure > maxWidth) {\n      // TODO - a divide and conquer method might be nicer.\n      var edgewords = function (word, maxWidth) {\n        var wlen = word.length;\n        if (wlen == 0) return [];\n        if (wlen == 1) return [word];\n        var awords = [],\n            cword = \"\",\n            cmeasure = 0,\n            letters = []; // Measure each letter.\n\n        for (var l = 0; l < wlen; l++) {\n          letters.push({\n            \"letter\": word[l],\n            \"measure\": ctx.measureText(word[l]).width\n          });\n        } // Assemble the letters into words of maximized length.\n\n\n        for (var ml in letters) {\n          var metaletter = letters[ml];\n\n          if (cmeasure + metaletter.measure > maxWidth) {\n            awords.push({\n              \"word\": cword,\n              \"len\": cword.length,\n              \"measure\": cmeasure\n            });\n            cword = \"\";\n            cmeasure = 0;\n          }\n\n          cword += metaletter.letter;\n          cmeasure += metaletter.measure;\n        } // there will always be one more word to push.\n\n\n        awords.push({\n          \"word\": cword,\n          \"len\": cword.length,\n          \"measure\": cmeasure\n        });\n        return awords;\n      }(word, maxWidth); // could use metawords = metawords.concat(edgwords)\n\n\n      for (var ew in edgewords) {\n        metawords.push(edgewords[ew]);\n      }\n    } else {\n      metawords.push({\n        \"word\": word,\n        \"len\": word.length,\n        \"measure\": measure\n      });\n    }\n  } // build array of lines second.\n\n\n  var cline = \"\";\n  var cmeasure = 0;\n\n  for (var mw in metawords) {\n    var metaword = metawords[mw]; // If current word doesn't fit on current line, push the current line and start a new one.\n    // Unless (edge-case): this is a new line and the current word is one character.\n\n    if (cmeasure + metaword.measure > maxWidth && cmeasure > 0 && metaword.len > 1) {\n      lines.push(cline);\n      cline = \"\";\n      cmeasure = 0;\n    }\n\n    cline += metaword.word;\n    cmeasure += metaword.measure; // If there's room, append a space, else push the current line and start a new one.\n\n    if (cmeasure + spacemeasure < maxWidth) {\n      cline += \" \";\n      cmeasure += spacemeasure;\n    } else {\n      lines.push(cline);\n      cline = \"\";\n      cmeasure = 0;\n    }\n  }\n\n  if (cmeasure > 0) {\n    lines.push(cline);\n  }\n\n  return lines;\n}\n\n//# sourceURL=webpack://tetris/./src/utils/fragmenttext.js?");

/***/ })

/******/ });